\chapter{Implementation}
\label{cha:implementation}
In this chapter, we describe how we implemented the simulation. First, section~\ref{sec:components} presents the various components we developed by describing what their task is, what we noticed during the implementation and why we implemented it this way. \textcolor{red}{module dependencies extra or in modules?} In section~\ref{sec:module_dependencies}, we describe the dependencies and interaction between the modules we developed. Section~\ref{sec:imp_communication} covers the implementation of the communication between Fawkes and Gazebo and between multiple robots we want to simulate. In section~\ref{sec:agent_improvements}, we present the improvements for the multi-agent system we implemented during the thesis.

\section{Components}
\label{sec:components}
\subsection{Gazebo Models}
\begin{figure}
\centering
\begin{subfigure}[b]{0.48\textwidth}
\includegraphics[width=\textwidth]{pics/llsf_real}
\caption{A Robotino delivers a puck to a recycling machine.}
\label{fig:comparison_real}
\end{subfigure}
\begin{subfigure}[b]{0.48\textwidth}
\includegraphics[width=\textwidth]{pics/llsf_sim}
\caption{The same situation in the Gazebo~simulation}
\label{fig:comparison_sim}
\end{subfigure}
\caption{Comparison of the real scene and the simulated scene in Gazebo}
\label{fig:comparison}
\end{figure}

In order to simulate the LLSF environment, we need to model all objects appearing in this domain. The models developed in this thesis are available at \url{https://github.com/zwilling/llsf-models.git}. Here, we present our simulation models and why we modeled them this way. Figure~\ref{fig:comparison} shows a comparison between a real LLSF scene and the same scene in the simulation. In this comparison, the most important objects of the simulation can be seen. In the following, we describe each model in detail:\\
\textbf{LLSF Field:} The model of the LLSF field has a rather simple structure. It consists of a ground plate and four side walls. For the visual appearance and possible future changes, the field has a visual representation with lines and colored areas just as on the real field. The machines are not realized as a component of the field and are attached to the field in the description of the simulation world.\\
\textbf{Machine:} The model of the machines matches the real machines structurally. Though, it is challenging to represent the lamps consisting of colored Plexiglas and a LED \textcolor{red}{abbreviation?} inside. We decided to use simple colored cylinders in the simulation. If the lamp is turned off, we use a dark and slightly transparent color and, if the light is turned on, we use a a bright color. This looks reasonable in the simulation and the images from the simulation are sufficient for our vision plugin which determines the lamp state of the machines. The vision plugin measures the brightness at the position where it expects the machine-lamp to be and it even was not necessary to change brightness thresholds. In Figure~\ref{fig:comparison_real}, the black RFID box in front of the machine is missing because we currently do not have the RFID readers.\\
\textbf{Puck:} The visual appearance of the puck model can be seen in Figure~\ref{fig:comparison_sim}. Physically, they are represented by a single cylinder. The difficult part was to find good friction parameters for the surface of the cylinder. On the one hand, it should be easy to slide the puck across the floor. On the other hand, the puck should stay inside the gripper of the Robotino when the Robotino turns. If the friction parameters are too small, the pucks move outside the gripper while turning because of the centrifugal force. \textcolor{red}{mention other solution?}\\
\textbf{Robotino:} The model of the Robotino is the most complex model because it holds different sensors, the casing and the puck gripper. It is also the most important one because it represents the robot we want to simulate. The major visual difference between real world and simulation is caused by the missing framework on top of the Robotino and the visual appearance of the puck gripper. Both is not important because we do net detect other Robotinos with a camera. We detect them with the laser sensor. Therefore and because of the manipulation with the gripper, the physical representation is more important. \textcolor{red}{collisions picture?} The physical model of the Robotino is composed of the gripper and two cylinders, one on the ground to represent the basic circle of the Robotino and one on laser and machine height. The cylinder on laser height is smaller and shifted back so that it does not block the laser sensor of the same Robotino and it fits better to the real shape. The gripper in the simulation has a similar shape than the real one. We needed to assign higher friction parameters to the inside of the gripper than to the outside because in reality the puck slides into the gripper if the front side of the gripper and stays in the gripper while turning. Because we were not able to simulate this with a single set of friction parameters, we modeled an additional geometry for the inside of the gripper with higher friction parameters. Originally, we intended to add wheels to the physical design for the final version. However, the omni-directional wheels caused an abnormal physical behavior in the simulation. The wheels irregularly bounced on the ground because of gravity and collision. Because we could not solve this problem in an arguable time and there is no important advantage, we decided to stay at the simple model without wheels. We only loose the possibility to physically simulate the odometry with its error. Therefore we introduced an artificially odometry error in the Gazebo plugin for the Robotino. \textcolor{red}{friction, setvel?}\\
\textbf{Simulation World:} The world file combines the developed models to an LLSF environment. Our world consists of the LLSF field, 16 machines with configurable orientation, 20 pucks and three Robotinos.\\


\subsection{Gazebo Plugins}
plugins for robot and worlds consisting of smaller reusable modules \textcolor{red}{refactoring necessary}
\textbf{World Plugin}
\\
\textbf{Robotino Plugin}
\\
\textbf{Native Plugins}


\subsection{Fawkes Plugins}
The Fawkes plugins developed in this thesis provide access to the simulation in Fawkes. In order to identify plugins for the Gazebo simulation quickly, we named them with the prefix \textit{Gazsim}. We divided the plugins into two groups. The first group of plugins generally cover the access to the Gazebo simulation, sensors and the Robotino robot without limitation to a specific domain or task. All these plugins can be found in the simulation branch of the Fawkes repository\footnote{http://git.fawkesrobotics.org/fawkes.git}. The second group of plugins are needed for the simulation of the LLSF environment. They can be found in our LLSF repository\footnote{http://git.fawkesrobotics.org/fawkes-robotino.git} which includes the general Fawkes repository. The access to the LLSF repository currently is limited because it contains new code we want to take advantage of in the LLSF competition.

\subsubsection{Common Gazebo and Robotino Plugins}
\textbf{Gazebo:} The plugin called \textit{Gazebo} provides general access to the Gazebo Transport API which is needed to communicate with the simulator. Therefore, it provides a Fawkes aspect also called \textit{Gazebo}. After connection to the Gazebo simulator, the aspect gives access to two communication nodes. One node is responsible for the communication with the simulated robot Fawkes should control and has to be initialized with the name of the robot in the simulation. The other node is responsible for the communication with the simulation world and therefore used for robot independent information environment information. It is also possible to spawn new models and visuals through this node. This is useful for controlling of the simulation and visualizing tasks to show, for example, the robot intention. \textcolor{red}{bei klingen noch nicht multi-roboter faehig?}
\\
\textbf{Gazsim-Robotino:}
The \textit{Gazsim-Robotino} plugin exchanges the Robotino plugin which connects Fawkes with the hardware of the Robotino robot. Therefore our plugin provides the same interfaces as the original plugin. The original plugin provides motor and sensor features, each with an own interface. Because both are combined in the original plugin, we also combine these two features in the simulation plugin. However, we developed separate modules for these two features to improve re-usability. The module responsible for the motor sends the wished motor movement to Gazebo and receives the position of the robot in the simulation to compute the odometry. Because sending many Protobuf messages has been found to be computationally costly, we only send messages if he wished movement has changed. Here we also introduced an error to the odometry which occurs more strong when the speed changes quickly. As in reality, the odometry also changes if the robot drives against an obstacle and does not change it's position. \textcolor{red}{important because driving against machine?} The module responsible for the sensors of the Robotino receives information from the simulated gyroscope and distance sensors of the Robotino.
\\
\textbf{Gazsim-Laser:}
The \textit{Gazsim-Laser} plugin exchanges the laser plugin and provides data from a simulated laser range sensor. The plugin converts received data into the in Fawkes used format and writes it into the laser-interface. \textcolor{red}{difference 5m-Nan?}
\\
\textbf{Gazsim-Localization:}
The plugin called \textit{Gazsim-Localization} receives the position of the robot in the simulation and publishes this information in the corresponding interface. Normally, this information is provided by plugins, such as amcl (Adaptive Monte Carlo Localization). Therefore this plugin operates on a higher level of abstraction. It uses ground truth information to allow testing high level components without error in the localization. 
\\
\textbf{Gazsim-Webcam:}
The \textit{Gazsim-Webcam} plugin receives a camera image from the gazebo simulation. It converts the received image from RGB\textcolor{red}{explain abbrv?}, which is used in Gazebo, into YUV\textcolor{red}{explain abbrv?}, which is used in Fawkes, and writes the image to a shared memory buffer. Unlike in other simulation plugins, there is no interface because vision plugins can directly load a camera through Fawkes tools. However, it is possible to load a shared memory image in the same way as a real camera. The vision plugin just has to be configured to use an other camera-identification string. We identify the shared memory images with the robot name as prefix because multiple Fawkes instances use the same set of shared memory images. Otherwise, there would be one shared memory image which alternately shows camera images from different robots.
\\
\textbf{Gazsim-Timesource:}
The \textit{Gazsim-Timesource} plugin provides the simulation time in Fawkes. This is important to avoid timing problems that occur if the computer is not able to run the simulation at real-time. Furthermore it allows to run the simulation faster than real time to speed up the testing process. The plugin replaces the default time-source in Fawkes. To provide a precise time avoid bad performance because of many synchronization messages, we decided to estimate the simulation time between two received time messages from Gazebo by using the current simulation speed and the real time passed since the last time synchronization message. To guarantee a monotonous time, we do not set the time in Fawkes back if the simulation has slowed down between two time synchronization messages. The error can create a error in time and is more acceptable than a worse performance with many  messages and a frozen time between two messages.
\textcolor{red}{measurement for created time error}\\
\textbf{Gazsim-Comm:}
The \textit{Gazsim-Comm} plugin simulates the communication between multiple Fawkes instances without using Gazebo. It runs on a separate Fawkes instance which does not control a simulated robot and acts similar to a hub. It uses a set of peer-to-peer connections to the different Fawkes instances and forwards broadcast messages from one peer to all other peers. This solves the problem that usually the different Fawkes instances communicate on the same ports which is not directly possible if the instances run on the same computer. We preferred this approach over others because also want to simulate communication over a bad wireless network. This is an important problem we want to simulate because during the RoboCup competition the wireless network usually is over-crowded. The package loss is simulated by the plugin by setting the likelihood for messages to be dropped before forwarding.
\\
\textbf{Gazsim-Vis-Localization:}
The \textit{Gazsim-Vis-Localization} plugin visualizes the localization of a robot in the simulation. It spawns a label which identifies the robot with an arrow which indicates the orientation of the robot above the position where the robot believes to be. The visualization is only visible from above so that the robot can not the label in the simulation. This visualization is very useful during testing because a wrong localization is one of the most common reasons for misbehaving of the robot. Without this visualization in the simulation, it would be time-consuming to check the localization of multiple robots because it would be necessary to look into a separate Rviz for each robot. Furthermore, the visualization can be used to indicate the localization of the robots in a reconstruction of an automated simulation run.
\\


\subsubsection{LLSF specific Plugins}
\textbf{Gazsim-Light-Front:}
\\
\textbf{Gazsim-Puck-Detection:}
\\
\textbf{Gazsim-LLSFrbcomm:}
\\
\textbf{Gazsim-LLSF-Control:}
\\
\textbf{Gazsim-LLSF-Statistics:}



\subsection{Automation Scripts}


\section{Module Dependencies}
\label{sec:module_dependencies}


\section{Communication}
\label{sec:imp_communication}


\section{Agent Improvements}
\label{sec:agent_improvements}
dynamic role switch: no more products ordered, \cite{dynamic_role_assignment}
